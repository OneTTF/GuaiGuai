<!DOCTYPE html>

<html lang="zh-CN">

	<head>

		<meta charset="UTF-8" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<title>ç«‹å†¬â˜ƒï¸</title>

		<style>

			* {

				box-sizing: border-box;

				margin: 0;

				padding: 0;

			}



			body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: #ffffff;
    min-height: 100dvh;
    overflow: hidden;
    /* æ–°å¢èƒŒæ™¯å›¾ç‰‡ç›¸å…³æ ·å¼ */
    background-image: url("bg.jpg"); /* å¼•å…¥ç›¸å¯¹ç›®å½•ä¸‹çš„ bg.jpg å›¾ç‰‡ */
    background-size: cover; /* å›¾ç‰‡è¦†ç›–æ•´ä¸ªå®¹å™¨ï¼Œå¯èƒ½ä¼šè£å‰ªå›¾ç‰‡ */
    background-repeat: no-repeat; /* å›¾ç‰‡ä¸é‡å¤æ˜¾ç¤º */
    background-position: center center; /* å›¾ç‰‡åœ¨å®¹å™¨ä¸­å±…ä¸­æ˜¾ç¤º */
    background-attachment: fixed; /* æ»šåŠ¨æ—¶èƒŒæ™¯å›¾ç‰‡å›ºå®šä¸åŠ¨ï¼ˆå¯é€‰ï¼Œæ ¹æ®éœ€æ±‚å†³å®šæ˜¯å¦ä¿ç•™ï¼‰ */
}




			body.is-mobile {

				overflow-y: auto;

			}



			#board {

				position: relative;

				width: 100vw;

				height: 100dvh;

				overflow: hidden;

			}



			.card {

				position: absolute;

				width: 180px;

				border-radius: 12px;

				box-shadow: 0 12px 28px rgba(0, 0, 0, 0.18);

				background: #fff;

				border: 1px solid rgba(0, 0, 0, 0.08);

				overflow: hidden;

				opacity: 0;

				transform-origin: center;

				transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,

					top 0.35s ease, width 0.35s ease, height 0.35s ease,

					border-radius 0.35s ease;

			}



			.card.dragging {

				transition: none;

				box-shadow: 0 18px 36px rgba(0, 0, 0, 0.28);

			}



			.card.maximized {

				box-shadow: 0 24px 48px rgba(0, 0, 0, 0.32);

			}



			.card-header {

				display: none;

			}



			.card-body {

				padding: 14px;

				font-size: 15px;

				line-height: 1.4;

				font-weight: 600;

				color: rgba(0, 0, 0, 0.7);

				word-break: break-word;

			}



			@media (max-width: 480px) {

				.card {

					width: min(72vw, 170px);

				}



				.card-body {

					padding: 12px;

					font-size: 14px;

				}



				.card-title {

					font-size: 11px;

				}

			}



/* å¯åŠ¨æŒ‰é’®æ ·å¼ - ä¼˜åŒ–ç‰ˆ */
#startOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(24, 28, 40, 0.95); /* æ·±ç°è“èƒŒæ™¯æ›´å…·ç§‘æŠ€æ„Ÿ */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999999;
  backdrop-filter: blur(6px); /* é™ä½æ¨¡ç³Šåº¦ï¼Œçªå‡ºå†…å®¹ */
  transition: opacity 0.6s ease;
}

/* æ–°å¢æ ‡é¢˜æ ·å¼ */
#startOverlay .overlay-title {
  font-size: 36px;
  font-weight: 700;
  color: #ffffff;
  margin-bottom: 8px;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

/* æ–°å¢å‰¯æ ‡é¢˜æ ·å¼ */
#startOverlay .overlay-desc {
  font-size: 16px;
  color: rgba(255, 255, 255, 0.8);
  margin-bottom: 36px;
  max-width: 500px;
  text-align: center;
  line-height: 1.5;
}

#startButton {
  padding: 16px 48px;
  font-size: 22px;
  font-weight: 600;
  color: #fff;
  background: linear-gradient(135deg, #4361ee, #3a0ca3); /* è“ç´«æ¸å˜æ›´å…·æ´»åŠ› */
  border: none;
  border-radius: 50px;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(67, 97, 238, 0.4);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  animation: pulse 2.2s ease-in-out infinite;
}

#startButton:hover {
  transform: scale(1.08);
  box-shadow: 0 12px 32px rgba(67, 97, 238, 0.6);
  background: linear-gradient(135deg, #3a0ca3, #2a096b); /* hoveræ—¶æ¸å˜åŠ æ·± */
}

#startButton:active {
  transform: scale(0.96);
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 8px 24px rgba(67, 97, 238, 0.4);
  }
  50% {
    transform: scale(1.05);
    box-shadow: 0 10px 28px rgba(67, 97, 238, 0.5);
  }
}

#musicStatus {
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 10px 20px;
  background: rgba(24, 28, 40, 0.85); /* ä¸overlayèƒŒæ™¯å‘¼åº” */
  color: #fff;
  border-radius: 20px;
  font-size: 14px;
  z-index: 10000;
  display: none;
  transition: all 0.3s ease;
}

#musicStatus.show {
  display: block;
  transform: translateY(0);
  opacity: 1;
}


		</style>

	</head>

	<body>

		

<div id="startOverlay">
    <h2 class="overlay-title">ç«‹å†¬â˜ƒï¸</h2>
    <p class="overlay-desc">æ‚¨æœ‰ä¸€ä»½ç«‹å†¬ç¤¼ç‰©ğŸï¼Œç¡®å®šè¦æ‰“å¼€å—</p>
    <button id="startButton">ç¡®å®š</button>
  </div>





		<div id="board"></div>

		<div id="musicStatus">ğŸµéŸ³ä¹æ’­æ”¾ä¸­...</div>

		<audio id="bgMusic" loop preload="auto">

			<source src="background.mp3" type="audio/mpeg">

		</audio>



		<script>

			const isMobileDevice =

				window.matchMedia('(pointer: coarse)').matches ||

				window.innerWidth <= 768



			if (!isMobileDevice) {

				window.location.replace('index.html')

			}



			const board = document.getElementById('board')

			const messages = [

				'ä¿æŒå¥½å¿ƒæƒ…',

				'å¤šå–æ°´å“¦',

				'ä»Šå¤©è¾›è‹¦å•¦',

				'æ—©ç‚¹ä¼‘æ¯',

				'è®°å¾—åƒæ°´æœ',

				'å°‘ç†¬å¤œ',

				'æ°¸è¿œé™ªç€ä½ ',

				'ä¿æŒå¾®ç¬‘å‘€',

				'æ„¿æ‰€æœ‰çƒ¦æ¼éƒ½æ¶ˆå¤±',

				'å¸Œæœ›ä½ åšè‡ªå·±',

				'æ¢¦æƒ³æ€»ä¼šå®ç°',

				'ç›¸ä¿¡è‡ªå·±',

				'ä¹Ÿå¸Œæœ›ä½ å°‘ç”Ÿæ°”',

				'å¾ˆå¤šäº‹æƒ…ä¸è¦è—åœ¨å¿ƒé‡Œ',

				'æœ‰ä½ çš„æ—¥å­æœ€ç”œèœœ',

				'æ¯å¤©çˆ±æˆ‘å¤šä¸€ç‚¹',

				'å’Œä½ ä¸€èµ·å˜è€',

				'ä¹–ä¹–å°‘å–é…’',

				'å¤©æ°”å†·äº†ï¼Œå¤šç©¿è¡£æœ',

				'è®°å¾—ç»™è‡ªå·±æ”¾æ¾',

				'æ¯å¤©éƒ½è¦å…ƒæ°”æ»¡æ»¡',

				'ä»Šå¤©ä¹Ÿè¦å¥½å¥½çˆ±è‡ªå·±',

				'é€‚å½“ä¼‘æ¯ä¸€ä¸‹',

				'ä»Šå¤©ä¹Ÿè¦å¼€å¿ƒå“¦',

				'è®°å¾—æ—©ç‚¹ç¡è§‰',

				'è®°å¾—åƒæ—©é¤'

			]



			const colors = [

				// ç²‰è‰²ç³»

				'#ffe0e3', // æµ…ç²‰

				'#ffd4f5', // ç²‰ç´«

				'#ffcce0', // ç«ç‘°ç²‰

				'#ffe5ec', // æ¨±èŠ±ç²‰

				'#ffd0e1', // èœœæ¡ƒç²‰

				'#ffb8d1', // çƒ­æƒ…ç²‰

				

				// è“è‰²ç³»

				'#c7f0ff', // å¤©è“

				'#d2f0f8', // å†°è“

				'#cfe2ff', // æµ…è“

				'#d5e8ff', // å¤©ç©ºè“

				'#b8e6ff', // æ¸…æ–°è“

				'#c7deff', // æ·¡è“

				

				// æ©™è‰²ç³»

				'#ffd8a8', // æµ…æ©™

				'#ffe4c4', // æä»è‰²

				'#ffdab9', // æ¡ƒè‰²

				'#ffead0', // é¦™æ§Ÿè‰²

				'#ffecc7', // å¥¶æ²¹æ©™

				

				// ç»¿è‰²ç³»

				'#d9f2d9', // æµ…ç»¿

				'#dff5e1', // è–„è·ç»¿

				'#d4f1d4', // æ¸…æ–°ç»¿

				'#e5f9e7', // å«©ç»¿

				'#d0f0d0', // è‰ç»¿

				

				// ç´«è‰²ç³»

				'#e5d7ff', // æµ…ç´«

				'#f0e5ff', // æ·¡ç´«

				'#e9dcff', // è–°è¡£è‰ç´«

				'#e0d1ff', // æ¢¦å¹»ç´«

				'#ead9ff', // æŸ”å’Œç´«

				

				// é»„è‰²ç³»

				'#f9f7d9', // æµ…é»„

				'#fff9db', // å¥¶é»„

				'#fef6d8', // æŸ æª¬é»„

				'#fffacd', // æ·¡é»„

				'#ffefd5', // é¦™è‰é»„

				

				// å…¶ä»–æ¸©æš–è‰²ç³»

				'#ffe6f0', // çŠç‘šç²‰

				'#ffd5e5', // ç”œå¿ƒç²‰

				'#d4f4ff', // å©´å„¿è“

				'#ffeef8', // æµªæ¼«ç²‰

				'#e0f8f7', // é’ç“·è‰²

				'#ffe8e0', // ææ¡ƒè‰²

				'#f5e5ff', // ä¸é¦™ç´«

				'#e8f8e8', // ç¿¡ç¿ ç»¿

				'#fff0e6', // è±¡ç‰™è‰²

				'#f0f8ff', // çˆ±ä¸½ä¸è“

				'#fef4f4', // è´å£³ç²‰

				'#f0fff0', // èœœç“œç»¿

				'#fff5f7', // è”·è–‡ç²‰

				'#f0f0ff', // å¹½çµç™½

				'#fffaf0'  // èŠ±ç™½è‰²

			]



			const cardStates = new WeakMap()

			const MAXIMIZED_LAYER = 1000000

			let activeMaximizedCard = null

			let isMobile = true

			const maxCards = 170

			const spawnInterval = 100

			const heartGatherDelay = 19000 // 23ç§’åå¼€å§‹æ±‡èš

			const heartAnimationDuration = 5000 // 8ç§’æ±‡èšåŠ¨ç”»

			const audioDuration = 33000 // éŸ³é¢‘æ—¶é•¿33ç§’

			let zIndexCursor = 200

			let animationTriggered = false

			let currentAnimationTimeouts = [] // å­˜å‚¨å½“å‰åŠ¨ç”»çš„æ‰€æœ‰å®šæ—¶å™¨



			document.body.classList.add('is-mobile')



			// è·å–å…ƒç´ 

			const bgMusic = document.getElementById('bgMusic')

			const startOverlay = document.getElementById('startOverlay')

			const startButton = document.getElementById('startButton')

			const musicStatus = document.getElementById('musicStatus')



			let hasStarted = false



			// ç‚¹å‡»å¼€å§‹æŒ‰é’®

			startButton.addEventListener('click', async () => {

				if (hasStarted) return

				hasStarted = true



				try {

					// æ’­æ”¾éŸ³ä¹

					await bgMusic.play()

					console.log('éŸ³ä¹å¼€å§‹æ’­æ”¾')

					

					// æ˜¾ç¤ºéŸ³ä¹çŠ¶æ€

					musicStatus.classList.add('show')

					setTimeout(() => {

						musicStatus.classList.remove('show')

					}, 3000)



					// æ·¡å‡ºå¯åŠ¨ç•Œé¢

					startOverlay.style.transition = 'opacity 0.5s ease'

					startOverlay.style.opacity = '0'

					setTimeout(() => {

						startOverlay.style.display = 'none'

					}, 500)



					// å¼€å§‹ç”Ÿæˆå¡ç‰‡

					startCardGeneration()

				} catch (error) {

					console.error('éŸ³ä¹æ’­æ”¾å¤±è´¥:', error)

					alert('éŸ³é¢‘æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·ç¡®ä¿ background.mp3 æ–‡ä»¶å­˜åœ¨')

				}

			})



			// ç›‘å¬éŸ³é¢‘é”™è¯¯

			bgMusic.addEventListener('error', (e) => {

				console.error('éŸ³é¢‘åŠ è½½é”™è¯¯:', e)

			})



			// ç›‘å¬éŸ³é¢‘æ’­æ”¾çŠ¶æ€

			bgMusic.addEventListener('play', () => {

				console.log('éŸ³é¢‘æ­£åœ¨æ’­æ”¾')

			})



			bgMusic.addEventListener('pause', () => {

				console.log('éŸ³é¢‘å·²æš‚åœ')

			})



			// ç›‘å¬éŸ³é¢‘æ’­æ”¾è¿›åº¦ï¼Œå½“éŸ³é¢‘å¾ªç¯æ—¶é‡ç½®åŠ¨ç”»

			let lastCurrentTime = 0

			bgMusic.addEventListener('timeupdate', () => {

				// æ£€æµ‹éŸ³é¢‘æ˜¯å¦é‡æ–°å¼€å§‹ï¼ˆä»å¤´æ’­æ”¾ï¼‰

				if (lastCurrentTime > 30 && bgMusic.currentTime < 3) {

					console.log('éŸ³é¢‘å¾ªç¯ï¼Œé‡ç½®åŠ¨ç”»')

					resetAndRestartAnimation()

				}

				lastCurrentTime = bgMusic.currentTime

			})



			function randomFrom(array) {

				return array[Math.floor(Math.random() * array.length)]

			}



			function clamp(value, min, max) {

				return Math.min(Math.max(value, min), max)

			}



			function generateHeartPoints(count) {

				const points = []

				const centerX = window.innerWidth / 2

				const centerY = window.innerHeight / 2



				const scaleFromHeight = (window.innerHeight * 0.78) / 30

				const maxWidth = window.innerWidth * 0.9

				let scale = scaleFromHeight

				if (scale * 32 > maxWidth) {

					scale = maxWidth / 32

				}



				for (let i = 0; i < count; i++) {

					const t = (i / count) * Math.PI * 2

					const x = 16 * Math.pow(Math.sin(t), 3)

					const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t))



					points.push({

						x: centerX + x * scale,

						y: centerY + y * scale

					})

				}



				return points

			}



			function triggerHeartAnimation() {

				if (animationTriggered) return

				animationTriggered = true



				const cards = Array.from(document.querySelectorAll('.card'))

				if (cards.length === 0) return



				const heartPoints = generateHeartPoints(cards.length)

				const centerX = window.innerWidth / 2

				const centerY = window.innerHeight / 2



				cards.forEach((card, index) => {

					const state = cardStates.get(card)

					if (!state || state.closing) return



					const point = heartPoints[index % heartPoints.length]

					const cardWidth = card.offsetWidth

					const cardHeight = card.offsetHeight



					card.style.pointerEvents = 'none'



					card.style.transition = `transform ${heartAnimationDuration}ms ease-in-out, opacity ${heartAnimationDuration}ms ease-in-out, left ${heartAnimationDuration}ms ease-in-out, top ${heartAnimationDuration}ms ease-in-out`



					state.left = point.x - cardWidth / 2

					state.top = point.y - cardHeight / 2

					state.scale = 0.3

					state.angle = 0



					card.style.left = `${state.left}px`

					card.style.top = `${state.top}px`

					applyTransform(card, state)

				})



				setTimeout(() => {

					showFinalCard({ centerX, centerY })

				}, heartAnimationDuration)

			}



			function showFinalCard({ centerX, centerY }) {

				const card = document.createElement('div')

				card.className = 'card final-card'



				const cardWidth = 220



				card.style.background = '#ff6b9d'

				card.style.left = `${centerX - cardWidth / 2}px`

				card.style.top = `${centerY}px`

				card.style.width = `${cardWidth}px`

				card.style.zIndex = MAXIMIZED_LAYER + 1

				card.style.pointerEvents = 'all'

				card.style.opacity = '0'

				card.style.transition = 'transform 600ms ease, opacity 600ms ease, top 600ms ease'



				card.innerHTML = `

					<div class="card-body" style="font-size: 24px; font-weight: bold; text-align: center; color: #fff; padding: 24px;">ä¹–ä¹– æ°¸è¿œçˆ±ä½ </div>

				`



				const state = {

					angle: 0,

					scale: 0.45,

					translateX: 0,

					translateY: 0,

					left: centerX - cardWidth / 2,

					top: centerY,

					maximized: false,

					closing: false

				}



				cardStates.set(card, state)

				applyTransform(card, state)

				board.appendChild(card)



				requestAnimationFrame(() => {

					const cardHeight = card.offsetHeight || 0

					const targetTop = centerY - cardHeight / 2



					state.top = targetTop

					card.style.top = `${state.top}px`



					state.scale = 1.05

					applyTransform(card, state)

					card.style.opacity = '1'



					setTimeout(() => {

						state.scale = 1

						applyTransform(card, state)

					}, 420)

				})



				// ç‚¹å‡»å¡ç‰‡å…³é—­

				card.addEventListener('click', event => {

					event.stopPropagation()

					card.style.opacity = '0'

					setTimeout(() => card.remove(), 350)

				})

			}



			function applyTransform(card, state) {

				const scale = state.scale ?? 1

				const translateX = state.translateX ?? 0

				const translateY = state.translateY ?? 0

				const angle = state.angle ?? 0

				card.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${angle}deg)`

			}



			function bringToFront(card) {

				if (card === activeMaximizedCard) {

					card.style.zIndex = MAXIMIZED_LAYER

					return

				}



				zIndexCursor += 1

				if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {

					zIndexCursor = MAXIMIZED_LAYER - 1

				}



				card.style.zIndex = zIndexCursor

			}



			function setupCardInteractions(card) {

				// å¡ç‰‡ç‚¹å‡»æå‡å±‚çº§

				card.addEventListener('pointerdown', () => {

					bringToFront(card)

				})



				// é•¿æŒ‰å…³é—­å¡ç‰‡ï¼ˆç§»åŠ¨ç«¯ï¼‰

				let pressTimer = null

				card.addEventListener('touchstart', event => {

					pressTimer = setTimeout(() => {

						closeCard(card)

					}, 800) // é•¿æŒ‰800mså…³é—­

				})



				card.addEventListener('touchend', () => {

					if (pressTimer) {

						clearTimeout(pressTimer)

						pressTimer = null

					}

				})



				card.addEventListener('touchmove', () => {

					if (pressTimer) {

						clearTimeout(pressTimer)

						pressTimer = null

					}

				})

			}



			function closeCard(card) {

				const state = cardStates.get(card)

				if (!state || state.closing) return

				if (card === activeMaximizedCard) {

					activeMaximizedCard = null

				}

				state.closing = true

				state.scale = 0.1

				card.style.opacity = '0'

				applyTransform(card, state)



				const handleTransitionEnd = event => {

					if (event.propertyName === 'opacity') {

						card.removeEventListener('transitionend', handleTransitionEnd)

						card.remove()

					}

				}



				card.addEventListener('transitionend', handleTransitionEnd)

			}



			function minimizeCard(card) {

				const state = cardStates.get(card)

				if (!state || state.closing) return



				const runMinimize = () => {

					state.closing = true

					bringToFront(card)

					const bottom = Math.max(window.innerHeight - 24, 0)

					const targetLeft = clamp(

						state.left,

						10,

						Math.max(window.innerWidth - card.offsetWidth - 10, 10)

					)



					state.left = targetLeft

					state.top = bottom

					state.scale = 0.12

					state.angle = 0

					card.style.left = `${targetLeft}px`

					card.style.top = `${bottom}px`

					card.style.opacity = '0.35'

					applyTransform(card, state)



					const handleTransitionEnd = event => {

						if (event.propertyName === 'transform') {

							card.removeEventListener('transitionend', handleTransitionEnd)

							card.remove()

						}

					}



					card.addEventListener('transitionend', handleTransitionEnd)

				}



				if (state.maximized) {

					activeMaximizedCard = null

					state.maximized = false

					card.classList.remove('maximized')

					card.style.borderRadius = '12px'

					state.left = 0

					state.top = 0

					state.scale = 1

					state.angle = 0

					applyTransform(card, state)



					requestAnimationFrame(() => {

						requestAnimationFrame(runMinimize)

					})

					return

				}



				runMinimize()

			}



			function toggleMaximize(card) {

				const state = cardStates.get(card)

				if (!state || state.closing) return



				if (state.maximized) {

					restoreFromMaximize(card, state)

				} else {

					maximizeCard(card, state)

				}

			}



			function maximizeCard(card, state) {

				state.beforeMaximize = {

					left: state.left,

					top: state.top,

					scale: state.scale ?? 1,

					width: card.offsetWidth,

					height: card.offsetHeight,

					angle: state.angle ?? 0

				}



				card.classList.add('maximized')

				card.style.left = '0px'

				card.style.top = '0px'

				card.style.width = `${window.innerWidth}px`

				card.style.height = `${window.innerHeight}px`

				card.style.borderRadius = '0'



				state.left = 0

				state.top = 0

				state.scale = 1

				state.angle = 0

				applyTransform(card, state)

				activeMaximizedCard = card

				bringToFront(card)

				state.maximized = true

			}



			function restoreFromMaximize(card, state) {

				const previous = state.beforeMaximize

				if (!previous) return



				card.classList.remove('maximized')

				card.style.left = `${previous.left}px`

				card.style.top = `${previous.top}px`

				card.style.width = `${previous.width}px`

				card.style.height = `${previous.height}px`

				card.style.borderRadius = '12px'



				state.left = previous.left

				state.top = previous.top

				state.scale = previous.scale ?? 1

				state.angle = previous.angle ?? state.angle ?? 0

				applyTransform(card, state)

				state.maximized = false

				if (activeMaximizedCard === card) {

					activeMaximizedCard = null

				}

				bringToFront(card)

				state.lastPosition = { left: state.left, top: state.top }



				setTimeout(() => {

					if (!state.maximized) {

						card.style.width = ''

						card.style.height = ''

						state.width = card.offsetWidth

						state.height = card.offsetHeight

					}

				}, 360)

			}





			function createCard() {

				const card = document.createElement('div')

				card.className = 'card'



				const color = randomFrom(colors)

				const angle = (Math.random() - 0.5) * 8

				const cardWidth = 180

				const cardHeight = 122

				const horizontalMargin = 10

				const verticalMargin = 10

				const left =

					horizontalMargin +

					Math.random() *

						Math.max(window.innerWidth - cardWidth - horizontalMargin * 2, 0)

				const top =

					verticalMargin +

					Math.random() *

						Math.max(window.innerHeight - cardHeight - verticalMargin * 2, 0)



				card.style.background = color

				card.style.left = `${left}px`

				card.style.top = `${top}px`

				if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER - 2) {

					zIndexCursor = MAXIMIZED_LAYER - 2

				}

				card.style.zIndex = ++zIndexCursor



				card.innerHTML = `

					<div class="card-body">${randomFrom(messages)}</div>

				`



				const state = {

					angle,

					scale: 0.9,

					translateX: 0,

					translateY: 0,

					left,

					top,

					maximized: false,

					closing: false,

					lastPosition: { left, top }

				}



				cardStates.set(card, state)

				applyTransform(card, state)

				board.appendChild(card)



				state.width = card.offsetWidth

				state.height = card.offsetHeight



				requestAnimationFrame(() => {

					state.scale = 1

					applyTransform(card, state)

					card.style.opacity = '1'

				})



				setupCardInteractions(card)



				if (board.children.length > maxCards) {

					const oldest = board.firstElementChild

					if (oldest && oldest !== card) {

						oldest.remove()

					}

				}

			}



			// å¼€å§‹ç”Ÿæˆå¡ç‰‡çš„å‡½æ•°

			function startCardGeneration() {

				// æ¸…ç©ºä¹‹å‰çš„å®šæ—¶å™¨

				currentAnimationTimeouts.forEach(timeout => clearTimeout(timeout))

				currentAnimationTimeouts = []



				// æŒ‰å‡åŒ€èŠ‚å¥ç”Ÿæˆå¡ç‰‡ç›´åˆ°æ±‡èšå¼€å§‹

				for (let delay = 0; delay < heartGatherDelay; delay += spawnInterval) {

					const timeout = setTimeout(() => {

						if (!animationTriggered) {

							createCard()

						}

					}, delay)

					currentAnimationTimeouts.push(timeout)

				}



				// åˆ°è¾¾æ±‡èšæ—¶é—´åè§¦å‘çˆ±å¿ƒåŠ¨ç”»

				const heartTimeout = setTimeout(() => {

					triggerHeartAnimation()

				}, heartGatherDelay)

				currentAnimationTimeouts.push(heartTimeout)

			}



			// é‡ç½®å¹¶é‡æ–°å¼€å§‹åŠ¨ç”»

			function resetAndRestartAnimation() {

				// æ¸…é™¤æ‰€æœ‰å®šæ—¶å™¨

				currentAnimationTimeouts.forEach(timeout => clearTimeout(timeout))

				currentAnimationTimeouts = []



				// é‡ç½®åŠ¨ç”»æ ‡å¿—

				animationTriggered = false



				// æ¸…é™¤æ‰€æœ‰å¡ç‰‡

				const allCards = document.querySelectorAll('.card')

				allCards.forEach(card => {

					card.style.transition = 'opacity 0.3s ease'

					card.style.opacity = '0'

					setTimeout(() => card.remove(), 300)

				})



				// é‡ç½® zIndex

				zIndexCursor = 200

				activeMaximizedCard = null



				// å»¶è¿Ÿä¸€ç‚¹åé‡æ–°å¼€å§‹åŠ¨ç”»

				setTimeout(() => {

					startCardGeneration()

				}, 500)

			}



			window.addEventListener('resize', () => {

				const stillMobile =

					window.matchMedia('(pointer: coarse)').matches ||

					window.innerWidth <= 768

				if (!stillMobile) {

					window.location.replace('index.html')

					return

				}



				document.body.classList.add('is-mobile')



				document.querySelectorAll('.card.maximized').forEach(card => {

					card.style.width = `${window.innerWidth}px`

					card.style.height = `${window.innerHeight}px`

				})

			})

		</script>

	</body>

</html>
